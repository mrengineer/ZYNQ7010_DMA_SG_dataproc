
/*********************************************************************/
/*                 TRANSFER MEMORY TO ZYNQ PL (MM2S)                 */
/*                 AND FROM ZYNQ PL TO MEMORY (S2MM)                 */
/*                                                                   */
/*            THIS C-CODE IS AUTOGENERATED BY gen-c.xslt             */
/*      COMPILE: gcc -Wall -o zynq-axi-dma-sg zynq-axi-dma-sg.c      */
/*             RUN as sudo: taskset -1 ./zynq-axi-dma-sg             */
/*********************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <time.h>
#include <sys/time.h>


/* 
        
from AXI DMA v7.1 - LogiCORE IP Product Guide http://www.xilinx.com/support/documentation/ip_documentation/axi_dma/v7_1/pg021_axi_dma.pdf

1. Write the address of the starting descriptor to the Current Descriptor register. If AXI DMA is configured for an address space greater than 32, then also program the MSB 32 bits of the current descriptor.
2. Start the MM2S channel running by setting the run/stop bit to 1 (MM2S_DMACR.RS =1). The Halted bit (DMASR.Halted) should deassert indicating the MM2S channel is running.
3. If desired, enable interrupts by writing a 1 to MM2S_DMACR.IOC_IrqEn and MM2S_DMACR.Err_IrqEn.
4. Write a valid address to the Tail Descriptor register. If AXI DMA is configured for an address space greater than 32, then also program the MSB 32 bits of the tail descriptor.
5. Writing to the Tail Descriptor register triggers the DMA to start fetching the descriptors from the memory. In case of multichannel configuration, the fetching of descriptors starts when the packet arrives on the S2MM channel.
6. The fetched descriptors are processed, Data is read from the memory and then output to the MM2S streaming channel.

*/
        
/*********************************************************************/
/*                       define mmap locations                       */
/*          consult the README for the exact memory layout           */
/*********************************************************************/

#define	AXI_DMA_REGISTER_LOCATION          0x40400000		//AXI DMA Register Address Map
#define	DESCRIPTOR_REGISTERS_SIZE          0xFFFF
#define	SG_DMA_DESCRIPTORS_WIDTH           0xFFFF
#define	MEMBLOCK_WIDTH                     0x1FFFFFF		//size of mem used by s2mm and mm2s
#define	BUFFER_BLOCK_WIDTH                 0x7D0000		//size of memory block per descriptor in bytes
#define	NUM_OF_DESCRIPTORS                 0x7		//number of descriptors for each direction

#define	HP0_DMA_BUFFER_MEM_ADDRESS         0x20000000
#define	HP0_MM2S_DMA_BASE_MEM_ADDRESS      (HP0_DMA_BUFFER_MEM_ADDRESS)
#define	HP0_S2MM_DMA_BASE_MEM_ADDRESS      (HP0_DMA_BUFFER_MEM_ADDRESS + MEMBLOCK_WIDTH + 1)
#define	HP0_MM2S_DMA_DESCRIPTORS_ADDRESS   (HP0_MM2S_DMA_BASE_MEM_ADDRESS)
#define	HP0_S2MM_DMA_DESCRIPTORS_ADDRESS   (HP0_S2MM_DMA_BASE_MEM_ADDRESS)
#define	HP0_MM2S_SOURCE_MEM_ADDRESS        (HP0_MM2S_DMA_BASE_MEM_ADDRESS + SG_DMA_DESCRIPTORS_WIDTH + 1)
#define	HP0_S2MM_TARGET_MEM_ADDRESS        (HP0_S2MM_DMA_BASE_MEM_ADDRESS + SG_DMA_DESCRIPTORS_WIDTH + 1)


/*********************************************************************/
/*                   define all register locations                   */
/*               based on "LogiCORE IP Product Guide"                */
/*********************************************************************/


        // MM2S CONTROL
#define MM2S_CONTROL_REGISTER       0x00    // MM2S_DMACR
#define MM2S_STATUS_REGISTER        0x04    // MM2S_DMASR
#define MM2S_CURDESC                0x08    // must align 0x40 addresses
#define MM2S_CURDESC_MSB            0x0C    // unused with 32bit addresses
#define MM2S_TAILDESC               0x10    // must align 0x40 addresses
#define MM2S_TAILDESC_MSB           0x14    // unused with 32bit addresses

#define SG_CTL                      0x2C    // CACHE CONTROL

// S2MM CONTROL
#define S2MM_CONTROL_REGISTER       0x30    // S2MM_DMACR
#define S2MM_STATUS_REGISTER        0x34    // S2MM_DMASR
#define S2MM_CURDESC                0x38    // must align 0x40 addresses
#define S2MM_CURDESC_MSB            0x3C    // unused with 32bit addresses
#define S2MM_TAILDESC               0x40    // must align 0x40 addresses
#define S2MM_TAILDESC_MSB           0x44    // unused with 32bit addresses

#define ENABLE_IOC_IRQ              0x00001000
#define ENABLE_DELAY_IRQ            0x00002000
#define ENABLE_ERR_IRQ              0x00004000
#define ENABLE_ALL_IRQ              0x00007000

void delay(int number_of_seconds)
{
    // Converting time into milli_seconds
    int milli_seconds = 1000 * number_of_seconds;
 
    // Storing start time
    clock_t start_time = clock();
 
    // looping till required time is not achieved
    while (clock() < start_time + milli_seconds)
        ;
}

unsigned int write_dma(unsigned int *virtual_addr, int offset, unsigned int value)
{
    virtual_addr[offset>>2] = value;

    return 0;
}

    int main() {

	unsigned int* axi_dma_register_mmap;
	unsigned int* mm2s_descriptor_register_mmap;
	unsigned int* s2mm_descriptor_register_mmap;
	unsigned int* source_mem_map;
	unsigned int* dest_mem_map;
	int controlregister_ok = 0,mm2s_status,s2mm_status;
	uint32_t mm2s_current_descriptor_address;
	uint32_t s2mm_current_descriptor_address;
	uint32_t mm2s_tail_descriptor_address;
	uint32_t s2mm_tail_descriptor_address;

	setbuf(stdout, NULL);

	printf("START\n");


	/*********************************************************************/
	/*               mmap the AXI DMA Register Address Map               */
	/*               the base address is defined in vivado               */
	/*                 by editing the offset address in                  */
	/*            address editor tab ("open block diagramm")             */
	/*********************************************************************/

	int dh = open("/dev/mem", O_RDWR | O_SYNC); 
	axi_dma_register_mmap = mmap(NULL, DESCRIPTOR_REGISTERS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, dh, AXI_DMA_REGISTER_LOCATION);
	//mm2s_descriptor_register_mmap = mmap(NULL, DESCRIPTOR_REGISTERS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, dh, HP0_MM2S_DMA_DESCRIPTORS_ADDRESS);
	s2mm_descriptor_register_mmap = mmap(NULL, DESCRIPTOR_REGISTERS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, dh, HP0_S2MM_DMA_DESCRIPTORS_ADDRESS);
	//source_mem_map = mmap(NULL, BUFFER_BLOCK_WIDTH * NUM_OF_DESCRIPTORS, PROT_READ | PROT_WRITE, MAP_SHARED, dh, (off_t)(HP0_MM2S_SOURCE_MEM_ADDRESS));
	dest_mem_map = mmap(NULL, BUFFER_BLOCK_WIDTH * NUM_OF_DESCRIPTORS, PROT_READ | PROT_WRITE, MAP_SHARED, dh, (off_t)(HP0_S2MM_TARGET_MEM_ADDRESS));
	int i;
	

	printf("nmaps are done\n");
	// fill mm2s-register memory with zeros
	//for (i = 0; i < DESCRIPTOR_REGISTERS_SIZE; i++) {
	//	char *p = (char *)mm2s_descriptor_register_mmap;
	//	p[i] = 0x00000000;
	//}

	// fill s2mm-register memory with zeros
    for (i = 0; i < DESCRIPTOR_REGISTERS_SIZE; i++) {
		char *p = (char *)s2mm_descriptor_register_mmap;
		p[i] = 0x00000000;
	}
	
	printf("s2mm-register memory with zeros is DONE\n");

	// fill source memory with a counter value
	//for (i = 0; i < (BUFFER_BLOCK_WIDTH / 4) * NUM_OF_DESCRIPTORS; i++) {
	//	unsigned int *p = source_mem_map;
	//	p[i] = 0x00000000 + i; 
	//}

	//printf("source memory with a counter value is DONE\n");

	// fill target memory with FFs
    //for (i = 0; i < (BUFFER_BLOCK_WIDTH / 4) * NUM_OF_DESCRIPTORS; i++) {
	//	unsigned int *p = dest_mem_map;
	//	p[i] = 0xffffffff;
	//}
	
	//printf("fill target memory with FFs is DONE\n");
	


        
	/*********************************************************************/
	/*                 reset and halt all dma operations                 */
	/*********************************************************************/

	//axi_dma_register_mmap[MM2S_CONTROL_REGISTER >> 2] =  0x4;
	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] =  0x4;
	//axi_dma_register_mmap[MM2S_CONTROL_REGISTER >> 2] =  0x0;
	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] =  0x0;

	printf("reset and halt all dma operations is DONE\n");

	/*********************************************************************/
	/*           build mm2s and s2mm stream and control stream           */
	/* chains will be filled with next desc, buffer width and registers  */
	/*                         [0]: next descr                           */
	/*                         [1]: reserved                             */
	/*                         [2]: buffer addr                          */
	/*********************************************************************/

	

	/*
	mm2s_current_descriptor_address = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS; // save current descriptor address

	mm2s_descriptor_register_mmap[0x0 >> 2] = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0x40; // set next descriptor address
	mm2s_descriptor_register_mmap[0x8 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0x0; // set target buffer address
	mm2s_descriptor_register_mmap[0x18 >> 2] = 0x87D0000; // set mm2s/s2mm buffer length to control register

	mm2s_descriptor_register_mmap[0x40 >> 2] = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0x80; // set next descriptor address
	mm2s_descriptor_register_mmap[0x48 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0x7D0000; // set target buffer address
	mm2s_descriptor_register_mmap[0x58 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	mm2s_descriptor_register_mmap[0x80 >> 2] = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0xC0; // set next descriptor address
	mm2s_descriptor_register_mmap[0x88 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0xFA0000; // set target buffer address
	mm2s_descriptor_register_mmap[0x98 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	mm2s_descriptor_register_mmap[0xC0 >> 2] = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0x100; // set next descriptor address
	mm2s_descriptor_register_mmap[0xC8 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0x1770000; // set target buffer address
	mm2s_descriptor_register_mmap[0xD8 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	mm2s_descriptor_register_mmap[0x100 >> 2] = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0x140; // set next descriptor address
	mm2s_descriptor_register_mmap[0x108 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0x1F40000; // set target buffer address
	mm2s_descriptor_register_mmap[0x118 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	mm2s_descriptor_register_mmap[0x140 >> 2] = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0x180; // set next descriptor address
	mm2s_descriptor_register_mmap[0x148 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0x2710000; // set target buffer address
	mm2s_descriptor_register_mmap[0x158 >> 2] = 0x7D0000; // set mm2s/s2mm buffer length to control register

	mm2s_descriptor_register_mmap[0x180 >> 2] = 0x00; // set next descriptor address (unused?)
	mm2s_descriptor_register_mmap[0x188 >> 2] = HP0_MM2S_SOURCE_MEM_ADDRESS + 0x2EE0000; // set target buffer address
	mm2s_descriptor_register_mmap[0x198 >> 2] = 0x47D0000; // set mm2s/s2mm buffer length to control register

	mm2s_tail_descriptor_address = HP0_MM2S_DMA_DESCRIPTORS_ADDRESS + 0x180 ; // save tail descriptor address
	*/

	s2mm_current_descriptor_address = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS; // save current descriptor address

	s2mm_descriptor_register_mmap[0x0 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x40; // set next descriptor address
	s2mm_descriptor_register_mmap[0x8 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + 0x0; // set target buffer address
	//s2mm_descriptor_register_mmap[0x18 >> 2] = BUFFER_BLOCK_WIDTH; //0x87D0000; // set mm2s/s2mm buffer length to control register
	s2mm_descriptor_register_mmap[0x18 >> 2] = 0x87D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x40 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x80; // set next descriptor address
	s2mm_descriptor_register_mmap[0x48 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + BUFFER_BLOCK_WIDTH; //0x7D0000; // set target buffer address
	s2mm_descriptor_register_mmap[0x58 >> 2] = BUFFER_BLOCK_WIDTH; //0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x80 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0xC0; // set next descriptor address
	s2mm_descriptor_register_mmap[0x88 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + (BUFFER_BLOCK_WIDTH*2); // set target buffer address
	s2mm_descriptor_register_mmap[0x98 >> 2] = BUFFER_BLOCK_WIDTH; //0x7D0000; // set mm2s/s2mm buffer length to control register


	s2mm_descriptor_register_mmap[0xC0 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x100; // set next descriptor address
	s2mm_descriptor_register_mmap[0xC8 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + (BUFFER_BLOCK_WIDTH*3); // set target buffer address
	s2mm_descriptor_register_mmap[0xD8 >> 2] = BUFFER_BLOCK_WIDTH; //0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x100 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x140; // set next descriptor address
	s2mm_descriptor_register_mmap[0x108 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + (BUFFER_BLOCK_WIDTH*4); // set target buffer address
	s2mm_descriptor_register_mmap[0x118 >> 2] = BUFFER_BLOCK_WIDTH; //0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x140 >> 2] = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x180; // set next descriptor address
	s2mm_descriptor_register_mmap[0x148 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + (BUFFER_BLOCK_WIDTH*5); // set target buffer address
	s2mm_descriptor_register_mmap[0x158 >> 2] = BUFFER_BLOCK_WIDTH; //0x7D0000; // set mm2s/s2mm buffer length to control register

	s2mm_descriptor_register_mmap[0x180 >> 2] = 0x200; // set next descriptor address (unused?)
	s2mm_descriptor_register_mmap[0x188 >> 2] = HP0_S2MM_TARGET_MEM_ADDRESS + (BUFFER_BLOCK_WIDTH*6); // set target buffer address
	//s2mm_descriptor_register_mmap[0x198 >> 2] = BUFFER_BLOCK_WIDTH; //0x47D0000; // set mm2s/s2mm buffer length to control register
	s2mm_descriptor_register_mmap[0x198 >> 2] = 0x47D0000; // set mm2s/s2mm buffer length to control register
	


	s2mm_tail_descriptor_address = HP0_S2MM_DMA_DESCRIPTORS_ADDRESS + 0x180 ; // save tail descriptor address

	printf("build s2mm stream and control stream is DONE\n");

	/*********************************************************************/
	/*                 set current descriptor addresses                  */
	/*           and start dma operations (S2MM_DMACR.RS = 1)            */
	/*********************************************************************/

	printf("S2MM_CURDESC is 0x%08x\n", axi_dma_register_mmap[S2MM_CURDESC>>2]);

	//axi_dma_register_mmap[MM2S_CURDESC>>2] =  mm2s_current_descriptor_address;
	axi_dma_register_mmap[S2MM_CURDESC>>2] =  s2mm_current_descriptor_address;

	printf("S2MM_CURDESC SET 0x%08x\n", axi_dma_register_mmap[S2MM_CURDESC>>2]);
	//axi_dma_register_mmap[MM2S_CONTROL_REGISTER >> 2] =  0x1;
	axi_dma_register_mmap[S2MM_CONTROL_REGISTER >> 2] =  0x1;



	// ENABLE IRQ
	//write_dma(axi_dma_register_mmap, MM2S_CONTROL_REGISTER, ENABLE_ALL_IRQ);
	//printf("IRQ ENABLED\n");



	/*********************************************************************/
	/*                          start transfer                           */
	/*                 (by setting the taildescriptors)                  */
	/*********************************************************************/

	//axi_dma_register_mmap[MM2S_TAILDESC>>2] =  mm2s_tail_descriptor_address;



	printf("S2MM_TAILDESC 0x%08x\n", axi_dma_register_mmap[S2MM_TAILDESC>>2]);
	axi_dma_register_mmap[S2MM_TAILDESC>>2] =  s2mm_tail_descriptor_address;
	printf("S2MM_TAILDESC SET 0x%08x\n", axi_dma_register_mmap[S2MM_TAILDESC>>2]);


	printf("wait until all transfers finished\n");

	/*********************************************************************/
	/*                 wait until all transfers finished                 */
	/*********************************************************************/

	char j = 0;

	while ((!controlregister_ok && j < 8))
    {
		j ++;
		//mm2s_status = axi_dma_register_mmap[MM2S_STATUS_REGISTER >> 2];
		s2mm_status = axi_dma_register_mmap[S2MM_STATUS_REGISTER >> 2];
		//controlregister_ok = ((mm2s_status & 0x00001000) && (s2mm_status & 0x00001000));
		controlregister_ok = ((s2mm_status & 0x00001000));
		
		/*
		printf("Memory-mapped to stream status (0x%08x@0x%02x):\n", mm2s_status, MM2S_STATUS_REGISTER);
		printf("MM2S_STATUS_REGISTER status register values:\n");
		if (mm2s_status & 0x00000001) printf(" halted"); else printf(" running");
		if (mm2s_status & 0x00000002) printf(" idle");
		if (mm2s_status & 0x00000008) printf(" SGIncld");
		if (mm2s_status & 0x00000010) printf(" DMAIntErr");
		if (mm2s_status & 0x00000020) printf(" DMASlvErr");
		if (mm2s_status & 0x00000040) printf(" DMADecErr");
		if (mm2s_status & 0x00000100) printf(" SGIntErr");
		if (mm2s_status & 0x00000200) printf(" SGSlvErr");
		if (mm2s_status & 0x00000400) printf(" SGDecErr");
		if (mm2s_status & 0x00001000) printf(" IOC_Irq");
		if (mm2s_status & 0x00002000) printf(" Dly_Irq");
		if (mm2s_status & 0x00004000) printf(" Err_Irq");
		printf("\n");*/

		printf("Stream to memory-mapped status (0x%08x@0x%02x):\n", s2mm_status, S2MM_STATUS_REGISTER);
		printf("S2MM_STATUS_REGISTER status register values:\n");
		if (s2mm_status & 0x00000001) {
			printf(" halted"); 			
		} 	else printf(" running");
		if (s2mm_status & 0x00000002) printf(" idle");
		if (s2mm_status & 0x00000008) printf(" SGIncld");
		if (s2mm_status & 0x00000010) {
			printf(" DMAIntErr");
			return 0;
		}
		if (s2mm_status & 0x00000020) printf(" DMASlvErr");
		if (s2mm_status & 0x00000040) printf(" DMADecErr");
		if (s2mm_status & 0x00000100) printf(" SGIntErr");
		if (s2mm_status & 0x00000200) printf(" SGSlvErr");
		if (s2mm_status & 0x00000400) printf(" SGDecErr");
		if (s2mm_status & 0x00001000) printf(" IOC_Irq");
		if (s2mm_status & 0x00002000) printf(" Dly_Irq");
		if (s2mm_status & 0x00004000) printf(" Err_Irq");
		s2mm_current_descriptor_address = (uint32_t) axi_dma_register_mmap[S2MM_CURDESC>>2];
		printf(" curdesc 0x%08x\n", s2mm_current_descriptor_address);
    }
    
	

	return 0;
}
























/**
 * Proof of concept offloaded memcopy using AXI Direct Memory Access v7.1


#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <sys/mman.h>

#define MM2S_CONTROL_REGISTER 0x00
#define MM2S_STATUS_REGISTER 0x04
#define MM2S_START_ADDRESS 0x18
#define MM2S_LENGTH 0x28

#define S2MM_CONTROL_REGISTER 0x30
#define S2MM_STATUS_REGISTER 0x34
#define S2MM_DESTINATION_ADDRESS 0x48
#define S2MM_LENGTH 0x58

unsigned int dma_set(unsigned int* dma_virtual_address, int offset, unsigned int value) {
    dma_virtual_address[offset>>2] = value;
}

unsigned int dma_get(unsigned int* dma_virtual_address, int offset) {
    return dma_virtual_address[offset>>2];
}

int dma_mm2s_sync(unsigned int* dma_virtual_address) {
    unsigned int mm2s_status =  dma_get(dma_virtual_address, MM2S_STATUS_REGISTER);
    while(!(mm2s_status & 1<<12) || !(mm2s_status & 1<<1) ){
        dma_s2mm_status(dma_virtual_address);
        dma_mm2s_status(dma_virtual_address);

        mm2s_status =  dma_get(dma_virtual_address, MM2S_STATUS_REGISTER);
    }
}

int dma_s2mm_sync(unsigned int* dma_virtual_address) {
    unsigned int s2mm_status = dma_get(dma_virtual_address, S2MM_STATUS_REGISTER);
    while(!(s2mm_status & 1<<12) || !(s2mm_status & 1<<1)){
        dma_s2mm_status(dma_virtual_address);
        dma_mm2s_status(dma_virtual_address);

        s2mm_status = dma_get(dma_virtual_address, S2MM_STATUS_REGISTER);
    }
}

void dma_s2mm_status(unsigned int* dma_virtual_address) {
    unsigned int status = dma_get(dma_virtual_address, S2MM_STATUS_REGISTER);
    printf("Stream to memory-mapped status (0x%08x@0x%02x):", status, S2MM_STATUS_REGISTER);
    if (status & 0x00000001) printf(" halted"); else printf(" running");
    if (status & 0x00000002) printf(" idle");
    if (status & 0x00000008) printf(" SGIncld");
    if (status & 0x00000010) printf(" DMAIntErr");
    if (status & 0x00000020) printf(" DMASlvErr");
    if (status & 0x00000040) printf(" DMADecErr");
    if (status & 0x00000100) printf(" SGIntErr");
    if (status & 0x00000200) printf(" SGSlvErr");
    if (status & 0x00000400) printf(" SGDecErr");
    if (status & 0x00001000) printf(" IOC_Irq");
    if (status & 0x00002000) printf(" Dly_Irq");
    if (status & 0x00004000) printf(" Err_Irq");
    printf("\n");
}

void dma_mm2s_status(unsigned int* dma_virtual_address) {
    unsigned int status = dma_get(dma_virtual_address, MM2S_STATUS_REGISTER);
    printf("Memory-mapped to stream status (0x%08x@0x%02x):", status, MM2S_STATUS_REGISTER);
    if (status & 0x00000001) printf(" halted"); else printf(" running");
    if (status & 0x00000002) printf(" idle");
    if (status & 0x00000008) printf(" SGIncld");
    if (status & 0x00000010) printf(" DMAIntErr");
    if (status & 0x00000020) printf(" DMASlvErr");
    if (status & 0x00000040) printf(" DMADecErr");
    if (status & 0x00000100) printf(" SGIntErr");
    if (status & 0x00000200) printf(" SGSlvErr");
    if (status & 0x00000400) printf(" SGDecErr");
    if (status & 0x00001000) printf(" IOC_Irq");
    if (status & 0x00002000) printf(" Dly_Irq");
    if (status & 0x00004000) printf(" Err_Irq");
    printf("\n");
}

void memdump(void* virtual_address, int byte_count) {
    char *p = virtual_address;
    int offset;
    for (offset = 0; offset < byte_count; offset++) {
        printf("%02x", p[offset]);
        if (offset % 4 == 3) { printf(" "); }
    }
    printf("\n");
}


int main() {
    int dh = open("/dev/mem", O_RDWR | O_SYNC); // Open /dev/mem which represents the whole physical memory
    unsigned int* virtual_address = mmap(NULL, 65535, PROT_READ | PROT_WRITE, MAP_SHARED, dh, 0x40400000); // Memory map AXI Lite register block
    unsigned int* virtual_source_address  = mmap(NULL, 65535, PROT_READ | PROT_WRITE, MAP_SHARED, dh, 0x0e000000); // Memory map source address
    unsigned int* virtual_destination_address = mmap(NULL, 65535, PROT_READ | PROT_WRITE, MAP_SHARED, dh, 0x0f000000); // Memory map destination address
    
    virtual_source_address[0]= 0x11223344; // Write random stuff to source block
    memset(virtual_destination_address, 0, 32); // Clear destination block
    
    printf("Source memory block:      "); memdump(virtual_source_address, 32);
    printf("Destination memory block: "); memdump(virtual_destination_address, 32);
    
    printf("Resetting DMA\n");
    dma_set(virtual_address, S2MM_CONTROL_REGISTER, 4);
    dma_set(virtual_address, MM2S_CONTROL_REGISTER, 4);
    dma_s2mm_status(virtual_address);
    dma_mm2s_status(virtual_address);
    
    printf("Halting DMA\n");
    dma_set(virtual_address, S2MM_CONTROL_REGISTER, 0);
    dma_set(virtual_address, MM2S_CONTROL_REGISTER, 0);
    dma_s2mm_status(virtual_address);
    dma_mm2s_status(virtual_address);

    printf("Writing destination address\n");
    dma_set(virtual_address, S2MM_DESTINATION_ADDRESS, 0x0f000000); // Write destination address
    dma_s2mm_status(virtual_address);

    printf("Writing source address...\n");
    dma_set(virtual_address, MM2S_START_ADDRESS, 0x0e000000); // Write source address
    dma_mm2s_status(virtual_address);

    printf("Starting S2MM channel with all interrupts masked...\n");
    dma_set(virtual_address, S2MM_CONTROL_REGISTER, 0xf001);
    dma_s2mm_status(virtual_address);
    
    printf("Starting MM2S channel with all interrupts masked...\n");
    dma_set(virtual_address, MM2S_CONTROL_REGISTER, 0xf001);    
    dma_mm2s_status(virtual_address);

    printf("Writing S2MM transfer length...\n");
    dma_set(virtual_address, S2MM_LENGTH, 32);
    dma_s2mm_status(virtual_address);

    printf("Writing MM2S transfer length...\n");
    dma_set(virtual_address, MM2S_LENGTH, 32);
    dma_mm2s_status(virtual_address);

    printf("Waiting for MM2S synchronization...\n");
    dma_mm2s_sync(virtual_address);

    printf("Waiting for S2MM sychronization...\n");
    dma_s2mm_sync(virtual_address); // If this locks up make sure all memory ranges are assigned under Address Editor!

    dma_s2mm_status(virtual_address);
    dma_mm2s_status(virtual_address);
    
    printf("Destination memory block: ");
    memdump(virtual_destination_address, 32);
}
 */

/*
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <termios.h>
#include <sys/mman.h>

#define MM2S_CONTROL_REGISTER       0x00
#define MM2S_STATUS_REGISTER        0x04
#define MM2S_SRC_ADDRESS_REGISTER   0x18
#define MM2S_TRNSFR_LENGTH_REGISTER 0x28

#define S2MM_CONTROL_REGISTER       0x30
#define S2MM_STATUS_REGISTER        0x34
#define S2MM_DST_ADDRESS_REGISTER   0x48
#define S2MM_BUFF_LENGTH_REGISTER   0x58

#define IOC_IRQ_FLAG                1<<12
#define IDLE_FLAG                   1<<1

#define STATUS_HALTED               0x00000001
#define STATUS_IDLE                 0x00000002
#define STATUS_SG_INCLDED           0x00000008
#define STATUS_DMA_INTERNAL_ERR     0x00000010
#define STATUS_DMA_SLAVE_ERR        0x00000020
#define STATUS_DMA_DECODE_ERR       0x00000040
#define STATUS_SG_INTERNAL_ERR      0x00000100
#define STATUS_SG_SLAVE_ERR         0x00000200
#define STATUS_SG_DECODE_ERR        0x00000400
#define STATUS_IOC_IRQ              0x00001000
#define STATUS_DELAY_IRQ            0x00002000
#define STATUS_ERR_IRQ              0x00004000

#define HALT_DMA                    0x00000000
#define RUN_DMA                     0x00000001
#define RESET_DMA                   0x00000004
#define ENABLE_IOC_IRQ              0x00001000
#define ENABLE_DELAY_IRQ            0x00002000
#define ENABLE_ERR_IRQ              0x00004000
#define ENABLE_ALL_IRQ              0x00007000

#define M							1 //8
*/

/*
cd /lib/firmware/xilinx/base
sync
fpgautil -R
fpgautil -o ./base.dtbo -b ./design_1_wrapper.bit


*/

//fpgautil -o /lib/firmware/xilinx/base/base.dtbo -b /lib/firmware/xilinx/base/design_1_wrapper.bit.bin

/*long long current_timestamp() {
    struct timeval te; 
    gettimeofday(&te, NULL); // get current time
    long long milliseconds = te.tv_sec*1000LL + te.tv_usec/1000; // calculate milliseconds
    // printf("milliseconds: %lld\n", milliseconds);
    return milliseconds;
}*/



/*
void delay(int number_of_seconds)
{
    // Converting time into milli_seconds
    int milli_seconds = 1000 * number_of_seconds;
 
    // Storing start time
    clock_t start_time = clock();
 
    // looping till required time is not achieved
    while (clock() < start_time + milli_seconds)
        ;
}

unsigned int write_dma(unsigned int *virtual_addr, int offset, unsigned int value)
{
    virtual_addr[offset>>2] = value;

    return 0;
}

unsigned int read_dma(unsigned int *virtual_addr, int offset)
{
    return virtual_addr[offset>>2];
}

void dma_s2mm_status(unsigned int *virtual_addr)
{
    unsigned int status = read_dma(virtual_addr, S2MM_STATUS_REGISTER);

    //printf("Stream to memory-mapped status (0x%08x@0x%02x):", status, S2MM_STATUS_REGISTER);

    //if (status & STATUS_HALTED) {
	//	printf(" Halted.\n");
	//} else {
	//	printf(" Running.\n");
	//}

    //if (status & STATUS_IDLE) {
	//	printf(" Idle.\n");
	//}

    if (status & STATUS_SG_INCLDED) {
		printf(" SG is included.\n");
	}

    if (status & STATUS_DMA_INTERNAL_ERR) {
		printf(" DMA internal error.\n");
	}

    if (status & STATUS_DMA_SLAVE_ERR) {
		printf(" DMA slave error.\n");
	}

    if (status & STATUS_DMA_DECODE_ERR) {
		printf(" DMA decode error.\n");
	}

    if (status & STATUS_SG_INTERNAL_ERR) {
		printf(" SG internal error.\n");
	}

    if (status & STATUS_SG_SLAVE_ERR) {
		printf(" SG slave error.\n");
	}

    if (status & STATUS_SG_DECODE_ERR) {
		printf(" SG decode error.\n");
	}

    //if (status & STATUS_IOC_IRQ) {
	//	printf(" IOC interrupt occurred.\n");
	//}

    if (status & STATUS_DELAY_IRQ) {
		printf(" Interrupt on delay occurred.\n");
	}

    if (status & STATUS_ERR_IRQ) {
		printf(" Error interrupt occurred.\n");
	}
}

void dma_mm2s_status(unsigned int *virtual_addr)
{
    unsigned int status = read_dma(virtual_addr, MM2S_STATUS_REGISTER);

    
	//printf("Memory-mapped to stream status (0x%08x@0x%02x):", status, MM2S_STATUS_REGISTER);

    //if (status & STATUS_HALTED) {
	//	printf(" Halted.\n");
	//} else {
	//	printf(" Running.\n");
	//}
	

    //if (status & STATUS_IDLE) {
	//	printf(" Idle.\n");
	//}

    if (status & STATUS_SG_INCLDED) {
		printf(" SG is included.\n");
	}

    if (status & STATUS_DMA_INTERNAL_ERR) {
		printf(" DMA internal error.\n");
	}

    if (status & STATUS_DMA_SLAVE_ERR) {
		printf(" DMA slave error.\n");
	}

    if (status & STATUS_DMA_DECODE_ERR) {
		printf(" DMA decode error.\n");
	}

    if (status & STATUS_SG_INTERNAL_ERR) {
		printf(" SG internal error.\n");
	}

    if (status & STATUS_SG_SLAVE_ERR) {
		printf(" SG slave error.\n");
	}

    if (status & STATUS_SG_DECODE_ERR) {
		printf(" SG decode error.\n");
	}

    //if (status & STATUS_IOC_IRQ) {
	//	printf(" IOC interrupt occurred.\n");
	//}

    if (status & STATUS_DELAY_IRQ) {
		printf(" Interrupt on delay occurred.\n");
	}

    if (status & STATUS_ERR_IRQ) {
		printf(" Error interrupt occurred.\n");
	}
}

int dma_mm2s_sync(unsigned int *virtual_addr)
{
    unsigned int mm2s_status =  read_dma(virtual_addr, MM2S_STATUS_REGISTER);

	// sit in this while loop as long as the status does not read back 0x00001002 (4098)
	// 0x00001002 = IOC interrupt has occured and DMA is idle
	while(!(mm2s_status & IOC_IRQ_FLAG) || !(mm2s_status & IDLE_FLAG))
	{
        dma_s2mm_status(virtual_addr);
        dma_mm2s_status(virtual_addr);

        mm2s_status =  read_dma(virtual_addr, MM2S_STATUS_REGISTER);
    }

	return 0;
}

int dma_s2mm_sync(unsigned int *virtual_addr)
{
    unsigned int s2mm_status = read_dma(virtual_addr, S2MM_STATUS_REGISTER);

	// sit in this while loop as long as the status does not read back 0x00001002 (4098)
	// 0x00001002 = IOC interrupt has occured and DMA is idle
	while(!(s2mm_status & IOC_IRQ_FLAG) || !(s2mm_status & IDLE_FLAG))
	{
        dma_s2mm_status(virtual_addr);
        dma_mm2s_status(virtual_addr);

        s2mm_status = read_dma(virtual_addr, S2MM_STATUS_REGISTER);
    }

	return 0;
}

void print_mem(void *virtual_address, int count)
{
	//char *data_ptr = virtual_address;
	u_int32_t *data_ptr = virtual_address;

	for(int i = 0; i < count; i ++){
		//printf("%02X ", data_ptr[i]);
		//printf("%ld", data_ptr[i]);

		// print a space every 4 bytes (0 indexed)
		//if(i%4==3){
		//	printf(" | ");
		//}

		printf("%i ", data_ptr[i]);
		
	}

	printf("\n");
}

int main()
{
    //printf("- Hello World! - Running DMA transfer test application.\n");

	printf("- Opening a character device file of the Arty's DDR memeory...\n");
	int ddr_memory = open("/dev/mem", O_RDWR | O_SYNC);

	printf("- Memory map the address of the DMA AXI IP via its AXI lite control interface register block.\n");
    unsigned int *dma_virtual_addr = mmap(NULL, 65535, PROT_READ | PROT_WRITE, MAP_SHARED, ddr_memory, 0x40400000);

	printf("- Memory map the MM2S source address register block.\n");
    unsigned int *virtual_src_addr  = mmap(NULL, 65535, PROT_READ | PROT_WRITE, MAP_SHARED, ddr_memory, 0x0e000000);

	printf("- Memory map the S2MM destination address register block.\n");
    unsigned int *virtual_dst_addr = mmap(NULL, 65535, PROT_READ | PROT_WRITE, MAP_SHARED, ddr_memory, 0x0f000000);

	printf("- Writing random data to source register block...\n");
	virtual_src_addr[0]= 0x00000001;
	virtual_src_addr[1]= 0x00000002;
	virtual_src_addr[2]= 0x00000003;
	virtual_src_addr[3]= 0x00000004;

	virtual_src_addr[4]= 0x00000005;
	virtual_src_addr[5]= 0x00000006;
	virtual_src_addr[6]= 0x00000007;
	virtual_src_addr[7]= 0x00000008;



	
	printf("> Clearing the destination register block...\n");
	memset(virtual_dst_addr, 0, 32*M);

		//if (i < 2) {
			printf("> Source memory block data:      ");
			print_mem(virtual_src_addr, 8);

			printf("> Destination memory block data: ");
			print_mem(virtual_dst_addr, 8);
		//}


		printf("> Reset the DMA.\n");
		write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, RESET_DMA);
		write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, RESET_DMA);
		dma_s2mm_status(dma_virtual_addr);
		dma_mm2s_status(dma_virtual_addr);


		printf("> Halt the DMA.\n");
		write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, HALT_DMA);
		write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, HALT_DMA);
		dma_s2mm_status(dma_virtual_addr);
		dma_mm2s_status(dma_virtual_addr);

		write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, ENABLE_ALL_IRQ);
		dma_s2mm_status(dma_virtual_addr);
		dma_mm2s_status(dma_virtual_addr);

		printf("> Writing source address of the data from MM2S in DDR...\n");
		write_dma(dma_virtual_addr, MM2S_SRC_ADDRESS_REGISTER, 0x0e000000);
		dma_mm2s_status(dma_virtual_addr);

		printf("> Writing the destination address for the data from S2MM in DDR...\n");
		write_dma(dma_virtual_addr, S2MM_DST_ADDRESS_REGISTER, 0x0f000000);
		dma_s2mm_status(dma_virtual_addr);

		printf("> Run the MM2S channel.\n");
		write_dma(dma_virtual_addr, MM2S_CONTROL_REGISTER, RUN_DMA);
		dma_mm2s_status(dma_virtual_addr);

		printf("> Run the S2MM channel.\n");
		write_dma(dma_virtual_addr, S2MM_CONTROL_REGISTER, RUN_DMA);		
		dma_s2mm_status(dma_virtual_addr);

		printf("\n\n\n");

	
	//while (1) {

	//	//printf("> Writing MM2S transfer length of 32 bytes...\n");
	//	write_dma(dma_virtual_addr, MM2S_TRNSFR_LENGTH_REGISTER, 32*4*M);
	//	dma_mm2s_status(dma_virtual_addr);

	//	//printf("> Writing S2MM transfer length of 32 bytes...\n");
	//	write_dma(dma_virtual_addr, S2MM_BUFF_LENGTH_REGISTER, 32*4*M);
	//	dma_s2mm_status(dma_virtual_addr);

	//	//printf("> Waiting for MM2S synchronization...\n");
	//	dma_mm2s_sync(dma_virtual_addr);
	//
	//	//printf("> Waiting for S2MM sychronization...\n");
	//	dma_s2mm_sync(dma_virtual_addr);

		
		
	//	print_mem(virtual_dst_addr, 8*4);
	//	delay(1);
	} 

for (char j = 0; j < 10; j++)
{
	


        write_dma(dma_virtual_addr, MM2S_TRNSFR_LENGTH_REGISTER, 32*4*M);
		dma_mm2s_status(dma_virtual_addr);

		write_dma(dma_virtual_addr, S2MM_BUFF_LENGTH_REGISTER, 32*4*M);
		dma_s2mm_status(dma_virtual_addr);

		dma_mm2s_sync(dma_virtual_addr);

		dma_s2mm_sync(dma_virtual_addr);
		
		print_mem(virtual_dst_addr, 8*4);
}

printf("\n\n\n");

 	unsigned long i=0;
    // Storing start time
    clock_t end_time = clock()+ 1000 * 1000;
 
    // looping till required time is not achieved
    while (clock() < end_time){
		i = i + 1;
        write_dma(dma_virtual_addr, MM2S_TRNSFR_LENGTH_REGISTER, 32*4*M);
		dma_mm2s_status(dma_virtual_addr);

		write_dma(dma_virtual_addr, S2MM_BUFF_LENGTH_REGISTER, 32*4*M);
		dma_s2mm_status(dma_virtual_addr);

		dma_mm2s_sync(dma_virtual_addr);

		dma_s2mm_sync(dma_virtual_addr);
		
		//print_mem(virtual_dst_addr, 8*4);
	}
	printf("%li lines done in 1 sec\n\n", i);

    return 0;
}*/
